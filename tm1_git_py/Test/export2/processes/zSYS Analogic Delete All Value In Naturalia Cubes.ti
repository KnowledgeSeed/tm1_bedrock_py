#region Prolog
#****Begin: Generated Statements***
#****End: Generated Statements****

# process made by David Ullmann - 20231106 - WORK IN PROGRESS
# This process is responsible to delete all data from fact periods, and fact data from plan periods.
# Later, this will be deprecated by the version implementation. Then, it will just simply delete all data from a version.
# view creation will be needed because of a specific filter requirement => period > actual

pRun = 0;

sDimensionName_Period   = 'Period';
sDimensionName_Loyalty  = 'Loyalty';
sDimensionName_Channel  = 'Sales Channel';
sDimensionName_SProduct = 'Source Product';
sDimensionName_TProduct = 'Target Product';
sDimensionName_Version  = 'Version';
sDimensionName_Movement = 'Subscription Plan Movement';
sDimensionName_Measure  = 'Subscription Plan Measure';
sHierarchyName_Period   = 'Period';
sHierarchyName_Loyalty  = 'Loyalty';
sHierarchyName_Channel  = 'Sales Channel';
sHierarchyName_SProduct = 'Source Product';
sHierarchyName_TProduct = 'Target Product';
sHierarchyName_Version  = 'Version';
sHierarchyName_Movement = 'Subscription Plan Movement';
sHierarchyName_Naturalia = 'Naturalia Page Movement';

sElementName_MovementMeasure = 'Stored';
sElementName_MovementTotal   = 'Closing';
sSubsetName_Period           = 'All N';
sValue_Version               = 'Base';
sValue_MeasureRead_Direct  = 'Value';  
sValue_MeasureWrite_Direct = 'Direct Input Override';
sValue_MeasureDelta_Direct = 'Direct Input Delta';
sValue_MeasureZero_Direct  = 'Direct Input Zero Flag';
sValue_MeasureRead_Spread  = 'Base';
sValue_MeasureWrite_Spread = 'Final Value Override';
sValue_MeasureDelta_Spread = 'Spread Input Delta';
sValue_MeasureResidual     = 'Spread Res';
sValue_MeasureZero_Spread  = 'Final Value Zero Flag';
svalue_MeasureFinal        = 'Final Value Snapshot';

sActualMonth = CellGetS('zSYS Maintenance Parameter', 'ActualMonth', 'S Type');

if(pRun = 1);
  
  # phase 1: data clear of subscription report -> keep input data on and after actual month
  sCube = 'Subscription Plan';
  
  sViewName = 'Subscription Plan Clear Temp';
  sFilter =          sDimensionName_SProduct | ' ¦ Total Products & ';
  sFilter = sFilter |sDimensionName_TProduct | ' ¦ Total Products & ';
  sFilter = sFilter |sDimensionName_Period   | ' ¦ All Periods & ';
  sFilter = sFilter |sDimensionName_Loyalty  | ' ¦ 0 & ';
  sFilter = sFilter |sDimensionName_Version  | ' ¦ '| pVersion |' & ';
  sFilter = sFilter |sDimensionName_Channel  | ' ¦ 0 & ';
  sFilter = sFilter |sDimensionName_Measure  | ' ¦ Base Input & ';
  sFilter = sFilter |sDimensionName_Movement | ' ¦ New increase';

  ExecuteProcess('}bedrock.cube.view.create',
     'pLogOutput', 0,
     'pStrictErrorHandling', 0,
     'pCube', sCube,
     'pView', sViewName,
     'pFilter', sFilter,
     'pSuppressZero', 1,
     'pSuppressConsol', 1,
     'pSuppressRules', 1,
     'pDimDelim', '&',
     'pEleStartDelim', '¦',
     'pEleDelim', '+',
     'pTemp', 1,
     'pSubN', 0,
     'pSuppressConsolStrings', 0
  );
  
  # every N-type movement
  sMDX = '{TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Movement|'].['|sDimensionName_Movement|'].[Closing]}, ALL, RECURSIVE )}, 0 )}';
  SubsetMDXSet(sDimensionName_Movement, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_Movement, sViewName, '');
  
  # all active and archive products from both groups (source, target)
  sMDX = 
    '{UNION(
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_SProduct|'].['|sDimensionName_SProduct|'].[Total Products]}, ALL, RECURSIVE )}, 0 )},
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_SProduct|'].['|sDimensionName_SProduct|'].[Total Products Archive]}, ALL, RECURSIVE )}, 0 )}
    )}';
  SubsetMDXSet(sDimensionName_SProduct, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_SProduct, sViewName, '');
  
  sMDX = 
    '{UNION(
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_TProduct|'].['|sDimensionName_TProduct|'].[Total Products]}, ALL, RECURSIVE )}, 0 )},
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_TProduct|'].['|sDimensionName_TProduct|'].[Total Products Archive]}, ALL, RECURSIVE )}, 0 )}
    )}';
  SubsetMDXSet(sDimensionName_TProduct, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_TProduct, sViewName, '');
  
  # all loyalty, all sales channels
  sMDX = '{TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Loyalty|'].['|sDimensionName_Loyalty|'].[Total]}, ALL, RECURSIVE )}, 0 )}';
  SubsetMDXSet(sDimensionName_Loyalty, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_Loyalty, sViewName, '');
  
  sMDX = '{TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Channel|'].['|sDimensionName_Channel|'].[Total]}, ALL, RECURSIVE )}, 0 )}';
  SubsetMDXSet(sDimensionName_Channel, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_Channel, sViewName, '');
  
  # all measures
  sMDX = '{TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Measure|'].['|sDimensionName_Measure|'].[Final Value]}, ALL, RECURSIVE )}, 0 )}';
  SubsetMDXSet(sDimensionName_Measure, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_Measure, sViewName, '');
  
  # all periods before actual month
  sMDX = 
  '{Filter(
    {Filter( 
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Period|'].['|sDimensionName_Period|'].[All Period]}, ALL, RECURSIVE )}, 0 )},
      InStr(['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name, "_Input") = 0 
    )},
    ['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name < "'|sActualMonth|'"
  )}';
  SubsetMDXSet(sDimensionName_Measure, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_Measure, sViewName, '');
  
  # viewzeroout #1: all data before actual month
  ViewZeroOut(sCube, sViewName);
  
  # fact data measures
  sMDX = '{TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Measure|'].['|sDimensionName_Measure|'].[Base]}, ALL, RECURSIVE )}, 0 )}';
  SubsetMDXSet(sDimensionName_Measure, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_Measure, sViewName, '');
  
  # all periods on and after actual month
  sMDX = 
  '{Filter(
    {Filter( 
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Period|'].['|sDimensionName_Period|'].[All Period]}, ALL, RECURSIVE )}, 0 )},
      InStr(['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name, "_Input") = 0 
    )},
    ['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name >= "'|sActualMonth|'"
  )}';
  SubsetMDXSet(sDimensionName_Measure, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_Measure, sViewName, '');

  # viewzeroout #2: fact data on and after actual month -> keep manual inputs 
  ViewZeroOut(sCube, sViewName);

  # phase 2: clear data of subscription report cube
  sCube = 'Subscription Report';

  ExecuteProcess( '}bedrock.cube.data.clear', 'pLogOutput', 0,
    'pStrictErrorHandling', 0,
  	'pCube', sCube,
  	'pView', '',
  	'pFilter', '',
  	'pFilterParallel', '',
  	'pParallelThreads', 0,
  	'pDimDelim', '&',
  	'pEleStartDelim', '¦', 'pEleDelim', '+',
  	'pCubeLogging', 0, 'pTemp', 1, 'pSandbox', '', 'pSubN', 0
	);

  

  sCube = 'XP Planning';
  sFilter = 'XP Planning Measure ¦ Base';

#  ExecuteProcess( '}bedrock.cube.data.clear', 'pLogOutput', 0,
#    'pStrictErrorHandling', 0,
#  	'pCube', sCube,
#  	'pView', '',
#  	'pFilter', sFilter,
#  	'pFilterParallel', '',
#  	'pParallelThreads', 0,
#  	'pDimDelim', '&',
#  	'pEleStartDelim', '¦', 'pEleDelim', '+',
#  	'pCubeLogging', 0, 'pTemp', 1, 'pSandbox', '', 'pSubN', 0
#);


  sCube = 'Weight and Limit';
  sFilter = 'Weight and Limit Measure ¦ Base';

#  ExecuteProcess( '}bedrock.cube.data.clear', 'pLogOutput', 0,
#    'pStrictErrorHandling', 0,
#  	'pCube', sCube,
#  	'pView', '',
#  	'pFilter', sFilter,
#  	'pFilterParallel', '',
#  	'pParallelThreads', 0,
#  	'pDimDelim', '&',
#  	'pEleStartDelim', '¦', 'pEleDelim', '+',
#  	'pCubeLogging', 0, 'pTemp', 1, 'pSandbox', '', 'pSubN', 0
#  );

endif;


#endregion
#region Metadata
#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Data
#****Begin: Generated Statements***
#****End: Generated Statements****



#endregion
#region Epilog
#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
