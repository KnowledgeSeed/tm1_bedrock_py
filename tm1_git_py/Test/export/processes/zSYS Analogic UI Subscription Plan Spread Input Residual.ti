#region Prolog
#****Begin: Generated Statements***
#****End: Generated Statements****

# =========================================================
# Original Date Created              2023.05.18
# Originator                         Ullmann Dávid
# Purpose                            Process to correct the rounding error of the input processes in the cube Subscription Plan
# Change Date                             calculates error and places the correction on the chosen element 
# Change Request Reference                
# Change Made by                     
# =========================================================

# collection of variables with possible use

sCubeName_Main          = 'Subscription Plan';
sCubeName_Assignment    = 'Subscription Movement Assignment';
sCubeName_WeightLimit   = 'Weight and Limit';
sDimensionName_Period   = 'Period';
sDimensionName_Loyalty  = 'Loyalty';
sDimensionName_Channel  = 'Sales Channel';
sDimensionName_SProduct = 'Source Product';
sDimensionName_TProduct = 'Target Product';
sDimensionName_Version  = 'Version';
sDimensionName_Movement = 'Subscription Plan Movement';
sDimensionName_Measure  = 'Subscription Plan Measure';
sHierarchyName_Period   = 'Period';
sHierarchyName_Loyalty  = 'Loyalty';
sHierarchyName_Channel  = 'Sales Channel';
sHierarchyName_SProduct = 'Source Product';
sHierarchyName_TProduct = 'Target Product';
sHierarchyName_Version  = 'Version';
sHierarchyName_Movement = 'Subscription Plan Movement';

sElementName_MovementMeasure = 'Stored';
sElementName_MovementTotal   = 'Closing';
sSubsetName_Period           = 'All N';
sValue_Version               = 'Base';
sValue_MeasureRead_Spread  = 'Base';
sValue_MeasureWrite_Spread = 'Final Value Override';
sValue_MeasureDelta_Spread = 'Spread Input Delta';
sValue_MeasureResidual     = 'Spread Res';
sValue_MeasureZero_Spread  = 'Final Value Zero Flag';
svalue_MeasureFinal        = 'Final Value';

# declaring variables for max calculation

nMaxValue = -1;
sMaxElementName_SProduct   = '';
sMaxElementName_TProduct   = '';
sMaxElementName_Movement   = '';
sMaxElementName_Channel    = '';
sMaxElementName_Loyalty    = '';
sMaxElementName_Period     = '';

# calculate residual

#pMovement = 'Total increase';

nSpreadOverride = CellGetN(sCubeName_Main, pVersion, pPeriod, pLoyalty, pChannel, pSourceProduct, pTargetProduct, pMovement, sValue_MeasureWrite_Spread);
nSpreadBase     = CellGetN(sCubeName_Main, pVersion, pPeriod, pLoyalty, pChannel, pSourceProduct, pTargetProduct, pMovement, sValue_MeasureRead_Spread); 
nSpreadDelta    = CellGetN(sCubeName_Main, pVersion, pPeriod, pLoyalty, pChannel, pSourceProduct, pTargetProduct, pMovement, sValue_MeasureDelta_Spread); 

pResidual = nSpreadOverride - (nSpreadBase + nSpreadDelta);

pResidual = pResidual + 1 * pTotalFactValue;

#LogOutput('INFO', 'Override: '|numbertostring(nSpreadOverride));
#LogOutput('INFO', 'Base: '|numbertostring(nSpreadBase));
#LogOutput('INFO', 'Delta: '|numbertostring(nSpreadDelta));
#LogOutput('INFO', 'Residual: '|numbertostring(pResidual));

# determine mode

nBypassMode = 0;
if(pResidual = 0);
  nBypassMode = 1;
endif;

sActualMonth = CellGetS('zSYS Maintenance Parameter', 'ActualMonth', 'S Type');

if(nBypassMode = 0);
  
  # create source view
  
  sViewName = 'Input Snapshot Temp';
#  sFilter =          sDimensionName_SProduct | ' ¦ '| pSourceProduct |' & ';
#  sFilter = sFilter |sDimensionName_TProduct | ' ¦ '| pTargetProduct |' & ';
#  sFilter = sFilter |sDimensionName_Period   | ' ¦ '| pPeriod |' & ';
#  sFilter = sFilter |sDimensionName_Loyalty  | ' ¦ '| pLoyalty |' & ';
#  sFilter = sFilter |sDimensionName_Version  | ' ¦ '| pVersion |' & ';
#  sFilter = sFilter |sDimensionName_Channel  | ' ¦ '| pChannel |' & ';
#  sFilter = sFilter |sDimensionName_Measure  | ' ¦ '| svalue_MeasureFinal |' & ';
#  sFilter = sFilter |sDimensionName_Movement | ' ¦ '| sElementName_MovementTotal;
#  
#  ExecuteProcess('}bedrock.cube.view.create',
#     'pLogOutput', 0,
#     'pStrictErrorHandling', 0,
#     'pCube', sCubeName_Main,
#     'pView', sViewName,
#     'pFilter', sFilter,
#     'pSuppressZero', 0,
#     'pSuppressConsol', 0,
#     'pSuppressRules', 0,
#     'pSuppressConsolStrings', -1,
#     'pDimDelim', '&',
#     'pEleStartDelim', '¦',
#     'pEleDelim', '+',
#     'pTemp',1,
#     'pSubN', 0
#  );
#    
#  # setting all N cells instead of C types  
#  
#  sMDX = '{TM1FilterByLevel({TM1DrillDownMember({['|sDimensionName_Loyalty|'].['|sDimensionName_Loyalty|'].['|pLoyalty|']},ALL,RECURSIVE)},0)}';
#  SubsetMDXSet(sDimensionName_Loyalty, sViewName, sMDX);
#  SubsetMDXSet(sDimensionName_Loyalty, sViewName, '');
#  
#  sMDX = '{TM1FilterByLevel({TM1DrillDownMember({['|sDimensionName_Channel|'].['|sDimensionName_Channel|'].['|pChannel|']},ALL,RECURSIVE)},0)}';
#  SubsetMDXSet(sDimensionName_Channel, sViewName, sMDX);
#  SubsetMDXSet(sDimensionName_Channel, sViewName, '');
#  
#  sMDX = '{TM1FilterByLevel({TM1DrillDownMember({['|sDimensionName_SProduct|'].['|sDimensionName_SProduct|'].['|pSourceProduct|']},ALL,RECURSIVE)},0)}';
#  SubsetMDXSet(sDimensionName_SProduct, sViewName, sMDX);
#  SubsetMDXSet(sDimensionName_SProduct, sViewName, '');
#  
#  sMDX = '{TM1FilterByLevel({TM1DrillDownMember({['|sDimensionName_TProduct|'].['|sDimensionName_TProduct|'].['|pTargetProduct|']},ALL,RECURSIVE)},0)}';
#  SubsetMDXSet(sDimensionName_TProduct, sViewName, sMDX);
#  SubsetMDXSet(sDimensionName_TProduct, sViewName, '');
#  
#  sMDX = '{TM1FilterByLevel({TM1DrillDownMember({['|sDimensionName_Movement|'].['|sDimensionName_Movement|'].['|pMovement|']},ALL,RECURSIVE)},0)}';
#  SubsetMDXSet(sDimensionName_Movement, sViewName, sMDX);
#  SubsetMDXSet(sDimensionName_Movement, sViewName, '');
#  
#  # filtering out the "input" periods
#  
  sMDX = 
  '{Filter(
    {Filter( 
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Period|'].['|sDimensionName_Period|'].['|pPeriod|']}, ALL, RECURSIVE )}, 0 )},
      InStr(['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name, "_Input") = 0 
    )},
    ['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name >= "'|sActualMonth|'"
  )}';
  SubsetMDXSet(sDimensionName_Period, sViewName, sMDX);
  SubsetMDXSet(sDimensionName_Period, sViewName, '');
  
  DataSourceType          = 'VIEW';
  DatasourceNameForServer = sCubeName_Main;
  DatasourceNameForClient = sCubeName_Main;
  DatasourceCubeView      = sViewName;
  
  # view is ready => start looking for strongest cell
endif;
#endregion
#region Metadata
#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Data
#****Begin: Generated Statements***
#****End: Generated Statements****

# don't find max if we don't have to put any residual

if(nBypassMode = 1);
  itemskip;
endif;

# find strongest cell - log coordinates

if(nValue > nMaxValue);
  nMaxValue = nValue;
  
  sMaxElementName_SProduct   = vSource;
  sMaxElementName_TProduct   = vTarget;
  sMaxElementName_Movement   = vMovement;
  sMaxElementName_Channel    = vChannel;
  sMaxElementName_Loyalty    = vLoyalty;
  sMaxElementName_Period     = vPeriod;
endif;
#endregion
#region Epilog
#****Begin: Generated Statements***
#****End: Generated Statements****

if(nBypassMode = 0);
  sOppositeMovement = AttrS(sDimensionName_Movement, sMaxElementName_Movement, 'Opposite');
  
  # put error correction on strongest cell
  
  CellPutN(pResidual, sCubeName_Main, pVersion, 
                                      sMaxElementName_Period, 
                                      sMaxElementName_Loyalty, 
                                      sMaxElementName_Channel, 
                                      
                                      sMaxElementName_SProduct, 
                                      sMaxElementName_TProduct, 
                                      
                                      sMaxElementName_Movement, 
                                      
                                      sValue_MeasureResidual);
  
  CellPutN(pResidual, sCubeName_Main, pVersion, 
                                      sMaxElementName_Period, 
                                      sMaxElementName_Loyalty, 
                                      sMaxElementName_Channel, 
                                      
                                      sMaxElementName_TProduct, 
                                      sMaxElementName_SProduct, 
                                      
                                      sOppositeMovement, 
                                      
                                      sValue_MeasureResidual);
endif;

CellPutN(1, 'zSYS Maintenance Parameter', 'NaturaliaSynchron', 'N type');
#endregion
