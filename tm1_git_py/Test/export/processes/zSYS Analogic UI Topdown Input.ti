#region Prolog
#****Begin: Generated Statements***
#****End: Generated Statements****

# made by David Ullmann - 2024.10.29 - input script to divide between products when a total is input

#sCubeWeight = 'Subscription Movement Assignment for Input';
sCubeWeight = 'Weight and Limit';
sCubeInput = 'Subscription Topdown';

sDimVersion = 'Version';
sDimPeriod = 'Period';
sDimProduct = 'Product';
sDimMovement = 'Subscription Topdown Movement';
sDimMeasure = 'Subscription Topdown Measure';
sMeasure = 'Override';

pProductCategory = CellGetS('}ElementAttributes_Product', pProduct, 'Product Category');
nZeroFlag = 0;
if(pInput = 0);
  nZeroFlag = 1;
endif;

#LogOutput('INFO', 'Product category subset name: ' | pProductCategory);

LogOutput('INFO', 'pVersion: '|pVersion|' - pPeriod: '|pPeriod|' - pProduct: '|pProduct|' - pMovement: '|pMovement|' - pInput:'|numbertostring(pInput));

#if(DimensionElementExists(sDimVersion, pVersion) = 0);
#  LogOutput('ERROR', 'Version does not exist');
#  ProcessQuit;
#endif;
#
#if(DimensionElementExists(sDimPeriod, pPeriod) = 0);
#  LogOutput('ERROR', 'Period does not exist');
#  ProcessQuit;
#endif;
#
#if(DimensionElementExists(sDimProduct, pProduct) = 0);
#  LogOutput('ERROR', 'Product does not exist');
#  ProcessQuit;
#endif;
#
#if(DimensionElementExists(sDimMovement, pMovement) = 0);
#  LogOutput('ERROR', 'Movement does not exist');
#  ProcessQuit;
#endif;
#
#if(SubsetExists(sDimProduct, pProductCategory) = 0);
#  LogOutput('ERROR', 'Product Category Subset does not exist');
#  ProcessQuit;
#endif;
#
pVersion = DimensionElementPrincipalName(sDimVersion, pVersion);
pPeriod = DimensionElementPrincipalName(sDimPeriod, pPeriod);
pProduct = DimensionElementPrincipalName(sDimProduct, pProduct);
pMovement = DimensionElementPrincipalName(sDimMovement, pMovement);

sMDX_Period = '{[Period].[Period].['|pPeriod|']}';

# calculate year parent of actual period -1
sActualMonth = CellGetS('zSYS Maintenance Parameter', 'ActualMonth', 'S Type');

sCheckYear = AttrS('Period', AttrS('Period', sActualMonth, 'PREV_1M'), 'Year');

if(pPeriod @= sCheckYear);
  LogOutput('INFO', 'Cannot input on actual year');
  ProcessQuit;
endif;
if(DType(sDimPeriod, pPeriod) @= 'N' & stringtonumber(pPeriod) < stringtonumber(sActualMonth));
  LogOutput('INFO', 'Cannot input on fact month');
  ProcessQuit;
endif;


if(DType(sDimPeriod, pPeriod) @<> 'N');
  sMDX_Period = '{TM1FilterByLevel({Tm1DrillDownMember({[Period].[Period].['|pPeriod|']}, ALL, RECURSIVE)},0)}';
endif;

sSubname = 'Period Temp Input';
if(SubsetExists('Period', sSubname) = 0);
  SubsetCreate('Period', sSubname, 1);
endif;
SubsetMDXSet('Period', sSubname, sMDX_Period);
SubsetMDXSet('Period', sSubname, '');
nSubsetSize = SubsetGetSize('Period', sSubname);


nBypass = 0;
if(DType(sDimProduct, pProduct) @= 'N');
  nBypass = 1;
endif;

nMaxValue = 0;
sMaxValueProduct = '';
nRoundedSpread = 0;

if(nBypass = 0);
  
  if(pMovement @= 'New increase' % pMovement @= 'Terminated increase' % pMovement @= 'Terminated decrease' % pMovement @= 'Loyalty Extension');
    nTotalWeight = CellGetN(sCubeInput, pVersion, pPeriod, pProduct, 'Opening', 'Base');
  elseif(pMovement @= 'Migration increase');
    #nTotalWeight = CellGetN(sCubeWeight, pVersion, pPeriod, pProductCategory|' Total', pProduct, 'Migration increase', 'Switch Off Weight');
    nTotalWeight = CellGetN(sCubeWeight, pVersion, pPeriod, pProduct,  'Switch on weight', 'Value');
  elseif(pMovement @= 'Migration decrese');
    #nTotalWeight = CellGetN(sCubeWeight, pVersion, pPeriod, pProductCategory|' Total', pProduct, 'Migration decrese', 'Switch On Weight');
    #nTotalWeight = CellGetN(sCubeWeight, pVersion, pPeriod, pProduct, pProductCategory|' Total', 'Migration increase', 'Switch Off Weight');
    nTotalWeight = CellGetN(sCubeWeight, pVersion, pPeriod, pProduct,  'Switch off weight', 'Value');
  endif;
  
  
#  only necessary if the two subsets differ. if we need the whole list, there is no need to create one, just set the existing
#
#  sSubName = 'Product Spread Temp '|numbertostring(int(rand(100000)));
#  SubsetCreate(sDimProduct, sSubName, 1);
#  sMDX = '{Tm1SubsetToSet([Source Product], "'|pProductCategory|'")}'
#  SubsetMDXSet(sDimProduct, sSubName, sMDX);

  # set subset as data source
  
  if(SubsetExists('Product', pProductCategory) = 0);
    LogOutput('ERROR', pProductCategory | 'nem lÃ©tezik');
  endif;
  
  DataSourceType            = 'SUBSET';
  DatasourceNameForServer   = 'Product';
  DatasourceNameForClient   = 'Product';
  DatasourceDimensionsubset = pProductCategory;
endif;
#endregion
#region Metadata
#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Data
#****Begin: Generated Statements***
#****End: Generated Statements****

if(nBypass = 1); itemskip; endif;
  
if(pMovement @= 'New increase' % pMovement @= 'Terminated increase' % pMovement @= 'Terminated decrease' % pMovement @= 'Loyalty Extension');
  nCurrentWeight = CellGetN(sCubeInput, pVersion, pPeriod, vProduct,  'Opening', 'Base');
elseif(pMovement @= 'Migration increase');
  #nCurrentWeight = CellGetN(sCubeWeight, pVersion, pPeriod, pProductCategory|' Total', vProduct, 'Migration increase', 'Switch On weight');
  nCurrentWeight = CellGetN(sCubeWeight, pVersion, pPeriod,  vProduct,  'Switch on weight', 'Value');
elseif(pMovement @= 'Migration decrese');
  #nCurrentWeight = CellGetN(sCubeWeight, pVersion, pPeriod, pProductCategory|' Total', vProduct, 'Migration decrese', 'Switch Off weight');
  nCurrentWeight = CellGetN(sCubeWeight, pVersion, pPeriod,  vProduct,  'Switch off weight', 'Value');
endif;

#LogOutput('INFO', numbertostring(nCurrentWeight) | ' ' | numbertostring(nTotalWeight) | ' ' | numbertostring(pInput));
#
nRatio = nCurrentWeight \ nTotalWeight;
nInput = pInput * nRatio;

if(nInput > nMaxValue);
  nMaxValue = nInput;
  sMaxValueProduct = vProduct;
endif;

#nRoundedSpread = nRoundedSpread + nInput;

#LogOutput('INFO', numbertostring(nInput));
nInputDivided = nInput / nSubsetSize;

nInputDivided = round(nInputDivided);

i = 1;
while(i <= nSubsetSize);
  sPeriodCurrent = HierarchySubsetGetElementName('Period', 'Period', sSubname, i);
  
  #LogOutput('INFO', 'Trying input on '| pVersion|' '|sPeriodCurrent|' '| vProduct|' '| pMovement|' '| sMeasure);
  #LogOutput('INFO', 'ratio: '|numbertostring(nRatio)|' Weights: '|numbertostring(nCurrentWeight) | ' '| numbertostring(nTotalWeight));
  
  CellPutN(nInputDivided, sCubeInput, pVersion, sPeriodCurrent, vProduct, pMovement, sMeasure);
  CellPutN(nZeroFlag, sCubeInput, pVersion, sPeriodCurrent, vProduct, pMovement, 'Zero Flag');
  i = i + 1;
end;

if(pMovement @= 'Migration increase');
  i = 1;
  while(i <= nSubsetSize);
    sPeriodCurrent = HierarchySubsetGetElementName('Period', 'Period', sSubname, i);
    CellPutN(0, sCubeInput, pVersion, sPeriodCurrent, vProduct, 'Migration decrese', sMeasure);
    CellPutN(0, sCubeInput, pVersion, sPeriodCurrent, vProduct, 'Migration decrese', 'Zero Flag');
    i = i + 1;
  end;
elseif(pMovement @= 'Migration decrese');
  i = 1;
  while(i <= nSubsetSize);
    sPeriodCurrent = HierarchySubsetGetElementName('Period', 'Period', sSubname, i);
    CellPutN(0, sCubeInput, pVersion, sPeriodCurrent, vProduct, 'Migration increase', sMeasure);
    CellPutN(0, sCubeInput, pVersion, sPeriodCurrent, vProduct, 'Migration increase', 'Zero Flag');
    i = i + 1;
  end;
endif;
#endregion
#region Epilog
#****Begin: Generated Statements***
#****End: Generated Statements****

if(nBypass = 1);
  CellPutN(pInput, sCubeInput, pVersion, pPeriod, pProduct, pMovement, sMeasure);
#else;
#  if(nRoundedSpread <> pInput);
#    CellIncrementN(pInput-nRoundedSpread, sCubeInput, pVersion, pPeriod, sMaxValueProduct, pMovement, sMeasure);
#  endif;
endif;
#endregion
