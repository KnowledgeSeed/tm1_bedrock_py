#region Prolog
#****Begin: Generated Statements***
#****End: Generated Statements****

# =========================================================
# Original Date Created              2023.06.12
# Originator                         Ullmann Dávid
# Purpose                            Process to spread the input in first dimension (in case of year) in the cube Subscription Plan
# Change Date                             First layer, Period
# Change Request Reference                
# Change Made by                     
# =========================================================

# collection of variables with possible use

sCubeName_Main          = 'Subscription Plan';
sCubeName_Assignment    = 'Subscription Movement Assignment';
sCubeName_WeightLimit   = 'Weight and Limit';
sDimensionName_Period   = 'Period';
sDimensionName_Loyalty  = 'Loyalty';
sDimensionName_Channel  = 'Sales Channel';
sDimensionName_SProduct = 'Source Product';
sDimensionName_TProduct = 'Target Product';
sDimensionName_Version  = 'Version';
sDimensionName_Movement = 'Subscription Plan Movement';
sDimensionName_Measure  = 'Subscription Plan Measure';
sHierarchyName_Period   = 'Period';
sHierarchyName_Loyalty  = 'Loyalty';
sHierarchyName_Channel  = 'Sales Channel';
sHierarchyName_SProduct = 'Source Product';
sHierarchyName_TProduct = 'Target Product';
sHierarchyName_Version  = 'Version';
sHierarchyName_Movement = 'Subscription Plan Movement';
sHierarchyName_Naturalia = 'Naturalia Page Movement';

sElementName_MovementMeasure = 'Stored';
sElementName_MovementTotal   = 'Closing';
sSubsetName_Period           = 'All N';
sValue_Version               = 'Base';
sValue_MeasureRead_Direct  = 'Value';  
sValue_MeasureWrite_Direct = 'Direct Input Override';
sValue_MeasureDelta_Direct = 'Direct Input Delta';
sValue_MeasureZero_Direct  = 'Direct Input Zero Flag';
sValue_MeasureRead_Spread  = 'Base';
sValue_MeasureWrite_Spread = 'Final Value Override';
sValue_MeasureDelta_Spread = 'Spread Input Delta';
sValue_MeasureResidual     = 'Spread Res';
sValue_MeasureZero_Spread  = 'Final Value Zero Flag';
svalue_MeasureFinal        = 'Final Value Snapshot';

MAX_RECURSION_INDEX = 0;

# for future usage, right now dont make it a parameter
#pVersion = sValue_Version;

# define next process name in chain
sProcessName_Next = 'zSYS Analogic UI Subscription Plan Input Spread Movement';

# never input negative
pInput = max(0, pInput);

# first, convert decrease movement to increase opposite
pMovement = HierarchyElementPrincipalName(sDimensionName_Movement, sHierarchyName_Movement, pMovement);

if(AttrN(sDimensionName_Movement, pMovement, 'DecreaseSideFlag') = 1);
  pMovement = AttrS(sDimensionName_Movement, pMovement, 'Opposite');
endif;

# convert name inputs to principal name without any special characters
pTargetProduct = DimensionElementPrincipalName(sDimensionName_TProduct, pTargetProduct);
pSourceProduct = DimensionElementPrincipalName(sDimensionName_SProduct, pSourceProduct);

# make a reader snapshot of the final value
ExecuteProcess('zSYS Analogic UI Subscription Plan Spread Input Snapshot',
   'pSourceProduct', pSourceProduct,
   'pTargetProduct', pTargetProduct,
   'pMovement', pMovement,
   'pLoyalty', pLoyalty,
   'pChannel', pChannel,
   'pPeriod', pPeriod,
   'pVersion', pVersion,
   'pRecursionIndex', pRecursionIndex
  );
  
sActualMonth = CellGetS('zSYS Maintenance Parameter', 'ActualMonth', 'S Type');
nActualPeriodIndex = DimIx(sDimensionName_Period, sActualMonth);

# determine modes of all layers
nPeriodBypass = 1;
if(ElementType(sDimensionName_Period, sDimensionName_Period, pPeriod) @= 'C');
  nPeriodBypass = 0;
  if(SubsetExists(sDimensionName_Period, 'Period Spread Temp') = 0);
    SubsetCreate(sDimensionName_Period, 'Period Spread Temp', 1);
  endif;
endif;



nMovementBypass = 1;
if(ElementType(sDimensionName_Movement, sDimensionName_Movement, pMovement) @= 'C');
  nMovementBypass = 0;
  if(SubsetExists(sDimensionName_Movement, 'Movement Spread Temp') = 0);
    SubsetCreate(sDimensionName_Movement, 'Movement Spread Temp', 1);
  endif;
endif;

#LogOutput('INFO', '===========================');
#LogOutput('INFO', '===========================');
#LogOutput('INFO', 'Movement: '|pMovement|' Movement bypass: '|numbertostring(nMovementBypass));
#LogOutput('INFO', '===========================');
#LogOutput('INFO', '===========================');

nSourceBypass = 1;
if(ElementType(sDimensionName_SProduct, sDimensionName_SProduct, pSourceProduct) @= 'C');
  nSourceBypass = 0;
  if(SubsetExists(sDimensionName_SProduct, 'Source Spread Temp') = 0);
    SubsetCreate(sDimensionName_SProduct, 'Source Spread Temp', 1);
  endif;
endif;

nTargetBypass = 1;
if(ElementType(sDimensionName_TProduct, sDimensionName_TProduct, pTargetProduct) @= 'C');
  nTargetBypass = 0;
  if(SubsetExists(sDimensionName_TProduct, 'Target Spread Temp') = 0);
    SubsetCreate(sDimensionName_TProduct, 'Target Spread Temp', 1);
  endif;
endif;

# create temp subset of all layers here - don't change the names, they are hardcoded - did not want to pass any more parameters




# create temp view for the inner layer
sViewName = 'Input Temp Inner';
sFilter =          sDimensionName_SProduct | ' ¦ '| pSourceProduct |' & ';
sFilter = sFilter |sDimensionName_TProduct | ' ¦ '| pTargetProduct |' & ';
sFilter = sFilter |sDimensionName_Period   | ' ¦ '| pPeriod |' & ';
sFilter = sFilter |sDimensionName_Loyalty  | ' ¦ '| pLoyalty |' & ';
sFilter = sFilter |sDimensionName_Version  | ' ¦ '| pVersion |' & ';
sFilter = sFilter |sDimensionName_Channel  | ' ¦ '| pChannel |' & ';
sFilter = sFilter |sDimensionName_Measure  | ' ¦ '| sValue_MeasureWrite_Spread |' & ';
sFilter = sFilter |sDimensionName_Movement | ' ¦ '| pMovement;

sMDX_Loyalty = '{TM1FilterByLevel({TM1DrillDownMember({['|sDimensionName_Loyalty|'].['|sDimensionName_Loyalty|'].['|pLoyalty|']},ALL,RECURSIVE)},0)}';
sMDX_Channel = '{TM1FilterByLevel({TM1DrillDownMember({['|sDimensionName_Channel|'].['|sDimensionName_Channel|'].['|pChannel|']},ALL,RECURSIVE)},0)}';

ExecuteProcess('}bedrock.cube.view.create',
 'pLogOutput', 0,
 'pStrictErrorHandling', 0,
 'pCube', sCubeName_Main,
 'pView', sViewName,
 'pFilter', sFilter,
 'pSuppressZero', 0,
 'pSuppressConsol', 1,
 'pSuppressRules', 0,
 'pSuppressConsolStrings', -1,
 'pDimDelim', '&',
 'pEleStartDelim', '¦',
 'pEleDelim', '+',
 'pTemp',1,
 'pSubN', 0
);

SubsetMDXSet(sDimensionName_Loyalty, sViewName, sMDX_Loyalty);
SubsetMDXSet(sDimensionName_Loyalty, sViewName, '');
SubsetMDXSet(sDimensionName_Channel, sViewName, sMDX_Channel);
SubsetMDXSet(sDimensionName_Channel, sViewName, '');



# start procedure of period spread
if(nPeriodBypass = 0);
  
  # get value total
  nTotalValue = 0;
  nTotalValue_Sign = 0;
  nFallbackRatioDivisor = 0;
  nTotalFactValue = 0;
  
  # generate subset of month
  sTempSubsetName_Period = 'Period Spread Temp';
  
  # first, use subset to calculate fact data sum, adjust input
   sMDX =
  '{Filter(
    {Filter( 
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Period|'].['|sDimensionName_Period|'].['|pPeriod|']}, ALL, RECURSIVE )}, 0 )},
      InStr(['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name, "_Input") = 0 
    )},
    ['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name < "'|sActualMonth|'"
  )}';
#  LogOutput('INFO', sMDX);
#  if(SubsetExists(sDimensionName_Period, sTempSubsetName_Period) = 0);
#    SubsetCreate(sDimensionName_Period, sTempSubsetName_Period, 1);
#  endif;
  SubsetMDXSet(sDimensionName_Period, sTempSubsetName_Period, sMDX);
  SubsetMDXSet(sDimensionName_Period, sTempSubsetName_Period, '');
  
  nIndex = 1;
  # only do this if there is factual data, subset size > 0
  while(nIndex <= SubsetGetSize(sDimensionName_Period, sTempSubsetName_Period));
    sCurrentPeriod = SubsetGetElementName(sDimensionName_Period, sTempSubsetName_Period, nIndex);
    nCurrentValue = CellGetN(sCubeName_Main, pVersion, sCurrentPeriod, pLoyalty, pChannel, pSourceProduct, pTargetProduct, pMovement, svalue_MeasureFinal);
    pInput = pInput - nCurrentValue;
    nTotalFactValue = nTotalFactValue + nCurrentValue;
    nIndex = nIndex + 1;
  end;
  
  
  # after fact data correction is done, use the period subset for its original purpose: simulation periods for the spread process
  sMDX =
  '{Filter(
    {Filter( 
      {TM1FilterByLevel( {TM1DrillDownMember( {['|sDimensionName_Period|'].['|sDimensionName_Period|'].['|pPeriod|']}, ALL, RECURSIVE )}, 0 )},
      InStr(['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name, "_Input") = 0 
    )},
    ['|sDimensionName_Period|'].['|sDimensionName_Period|'].CurrentMember.Name >= "'|sActualMonth|'"
  )}';
#  LogOutput('INFO', sMDX);
#  if(SubsetExists(sDimensionName_Period, sTempSubsetName_Period) = 0);
#    SubsetCreate(sDimensionName_Period, sTempSubsetName_Period, 1);
#  endif;
  SubsetMDXSet(sDimensionName_Period, sTempSubsetName_Period, sMDX);
  SubsetMDXSet(sDimensionName_Period, sTempSubsetName_Period, '');

  # set subset as data source 
  DataSourceType            = 'SUBSET';
  DatasourceNameForServer   = sDimensionName_Period;
  DatasourceNameForClient   = sDimensionName_Period;
  DatasourceDimensionsubset = sTempSubsetName_Period;
endif;
#endregion
#region Metadata
#****Begin: Generated Statements***
#****End: Generated Statements****

nCurrentMonthFinalValue = CellGetN(sCubeName_Main, pVersion, vPeriod, pLoyalty, pChannel, pSourceProduct, pTargetProduct, pMovement, svalue_MeasureFinal);
#LogOutput('INFO', 'month data currently: ' |  numbertostring(nCurrentMonthFinalValue));
#
#if(DimIx(sDimensionName_Period, vPeriod) >= nActualPeriodIndex);
  nTotalValue = nTotalValue + nCurrentMonthFinalValue;
  nTotalValue_Sign = Abs(Sign(nTotalValue));
  nFallbackRatioDivisor = nFallbackRatioDivisor + 1;
#  
#  LogOutput('INFO', 'Total at current:'|numbertostring(nTotalValue));
#  LogOutput('INFO', 'TotalSignum at current:'|numbertostring(nTotalValue_Sign));
#  LogOutput('INFO', 'Divisor currently: ' | numbertostring(nFallbackRatioDivisor));
#else;
#  pInput = pInput - nCurrentMonthFinalValue;
#  LogOutput('INFO', 'Input at current:'|numbertostring(pInput));
#endif;
#
#LogOutput('INFO', '
#=========================
#');
#


#endregion
#region Data
#****Begin: Generated Statements***
#****End: Generated Statements****

if(nPeriodBypass = 1);
  itemskip;
endif;

#if(DimIx(sDimensionName_Period, vPeriod) < nActualPeriodIndex);
#  itemskip;
#endif;

# in case total is no data on total (everything is zero)
nFallbackRatio = 1 / nFallbackRatioDivisor;

# in case there is data on total
nCurrentValue  = CellGetN(sCubeName_Main, pVersion, vPeriod, pLoyalty, pChannel, pSourceProduct, pTargetProduct, pMovement, svalue_MeasureFinal);
nBaseRatio     = nCurrentValue \ nTotalValue;

# get final ratio and value part to pass
nRatio         = nTotalValue_Sign * nBaseRatio + (1 - nTotalValue_Sign) * nFallbackRatio;

# if ratio is zero, stop branch

nOverridepart  = pInput * nRatio;

if(nOverridepart = 0);
  itemskip;
endif;

# debug logs
#LogOutput('INFO', 'Total value signum: ' | numbertostring(nTotalValue_Sign));
#LogOutput('INFO', 'Current Value: ' | numbertostring(nCurrentValue));
#LogOutput('INFO', 'Total Value: ' | numbertostring(nTotalValue));
#LogOutput('INFO', 'Current value ratio: ' | numbertostring(nBaseRatio));
#LogOutput('INFO', 'Fallback ratio: ' | numbertostring(nFallbackRatio));
#LogOutput('INFO', 'Final Ratio: ' | numbertostring(nRatio));
#LogOutput('INFO', 'Override part: ' | numbertostring(nOverridepart));

#itemskip;

# call subprocess to divide further
ExecuteProcess(sProcessName_Next,
 'pSourceProduct', pSourceProduct,
 'pTargetProduct', pTargetProduct,
 'pMovement', pMovement,
 'pLoyalty', pLoyalty,
 'pChannel', pChannel,
 'pPeriod', vPeriod,
 'pVersion', pVersion,
 'pMaincategory', pMaincategory,
 'pInput', nOverridepart,
 'pMovementBypass', nMovementBypass,
 'pSourceBypass', nSourceBypass,
 'pTargetBypass', nTargetBypass
 );
  

#endregion
#region Epilog
#****Begin: Generated Statements***
#****End: Generated Statements****

# if bypass, hand values to next process

if(nPeriodBypass = 1);
  ExecuteProcess(sProcessName_Next, 
  'pSourceProduct', pSourceProduct, 
  'pTargetProduct', pTargetProduct, 
  'pMovement', pMovement, 
  'pLoyalty', pLoyalty, 
  'pChannel', pChannel, 
  'pPeriod', pPeriod,
  'pVersion', pVersion,
  'pMaincategory', pMaincategory,
  'pInput', pInput,
   'pMovementBypass', nMovementBypass,
   'pSourceBypass', nSourceBypass,
   'pTargetBypass', nTargetBypass);
endif;

# end writing process by correcting the rounding errors

ExecuteProcess('zSYS Analogic UI Subscription Plan Spread Input Residual',
 'pSourceProduct', pSourceProduct,
 'pTargetProduct', pTargetProduct,
 'pMovement', pMovement,
 'pLoyalty', pLoyalty,
 'pChannel', pChannel,
 'pPeriod', pPeriod,
 'pVersion', pVersion,
 'pTotalFactValue', nTotalFactValue);
 
nRunLimits = 0; 
if(pRecursionIndex < 1 & nRunLimits = 1);
  
#  LogOutput('INFO', 'running limits module');
  
  ExecuteProcess('zSYS Analogic UI Subscription Plan Spread Input Limit',
     'pSourceProduct', pSourceProduct,
     'pTargetProduct', pTargetProduct,
     'pMovement', pMovement,
     'pMaincategory', pMaincategory,
     'pLoyalty', pLoyalty,
     'pChannel', pChannel,
     'pPeriod', pPeriod,
     'pVersion', pVersion,
     'pInput', pInput,
     'pSourceBypass', nSourceBypass,
     'pTargetBypass', nTargetBypass
    );
endif;


# Módos Dávid 2024 02 13

sToday = Today(1);
CellPutS(sToday, '}ElementAttributes_Version', pVersion, 'Last Updated');
CellPutS(pUser, '}ElementAttributes_Version', pVersion, 'Last Updated By');

#endregion
